@startuml CompleteActivityDiagram
header
generated on 12.03.2024 22:57:00
end header
title CompleteActivityDiagram
start
note right:  Program.Main
#Lavender:Params(string[] args);
#LightBlue:string input
int[,] field = new int[0, 0]
int occupancy;
:Console.Clear();
:PrintLine("GameOfLife");
:PrintLine("==========");
:PrintLine();
:PrintLine("1...Erstellen eines zufälligen Feldes (79 * 20 Zellen)");
:PrintLine("2...Erstellen eines Blinkers (Blinker.csv)");
:PrintLine("3...Erstellen eines Blinkers II (Blinker2.csv)");
:PrintLine("4...Erstellen eines Bipols (Bipol.csv)");
:PrintLine();
:Print("Wählen Sie eine Option: ");
:input = ReadLine();
if (input == "1") then (<color:green>yes)
    repeat
        :Print($"Wieviele Zellen sollen lebendig sein <Max: {MAX_ROWS * MAX_COLS}> ? ");
        :input = ReadLine();
    repeat while (!int.TryParse(input, out occupancy) || occupancy < 0 || occupancy > MAX_ROWS * MAX_COLS) is (<color:green>yes)
    :field = CreateRandomField(MAX_ROWS, MAX_COLS, occupancy);
  else (<color:red>no)
    if (input == "2") then (<color:green>yes)
        :field = ReadFieldFromCsvFile("Blinker.csv");
      else (<color:red>no)
        if (input == "3") then (<color:green>yes)
            :field = ReadFieldFromCsvFile("Blinker2.csv");
          else (<color:red>no)
            if (input == "4") then (<color:green>yes)
                :field = ReadFieldFromCsvFile("Bipol.csv");
              else (<color:red>no)
                  :PrintLine("Ungültige Eingabe!");
            endif
        endif
    endif
endif
:Simulate(field, 1000, 250);
stop
start
note right:  Program.Simulate
#Lavender:Params(int[,] field, int iterations, int delay);
:PrintField(field);
:Thread.Sleep(delay);
#LightBlue:int i = 0;
while (i < iterations && SumCellValues(field) > 0) is (<color:green>yes)
    :field = CreateNextGeneration(field);
    :PrintField(field);
    :Thread.Sleep(delay);
:i++;
endwhile (<color:red>no)
stop
start
note right:  Program.SumCellValues
#Lavender:Params(int[,] field);
#LightBlue:int sum = 0;
#LightBlue:int r = 0;
while (r < field.GetLength(0)) is (<color:green>yes)
    #LightBlue:int c = 0;
    while (c < field.GetLength(1)) is (<color:green>yes)
        :sum += field[r, c];
    :c++;
    endwhile (<color:red>no)
:r++;
endwhile (<color:red>no)
#Lavender:return sum;
stop
start
note right:  Program.GetLivingNeighbors
#Lavender:Params(int[,] field, int row, int col);
#LightBlue:int result = 0
int rowCount = field.GetLength(0)
int colCount = field.GetLength(1);
#LightBlue:int r = row - 1;
while (r <= row + 1) is (<color:green>yes)
    #LightBlue:int c = col - 1;
    while (c <= col + 1) is (<color:green>yes)
        #LightBlue:int rIdx = r < 0 ? rowCount - 1 : r >= rowCount ? 0 : r;
        #LightBlue:int cIdx = c < 0 ? colCount - 1 : c >= colCount ? 0 : c;
        if (rIdx == row && cIdx == col) then (<color:green>yes)
          :result += 0;
          else (<color:red>no)
            :result += field[rIdx, cIdx];
        endif
    :c++;
    endwhile (<color:red>no)
:r++;
endwhile (<color:red>no)
#Lavender:return result;
stop
start
note right:  Program.CreateNextGeneration
#Lavender:Params(int[,] currentField);
#LightBlue:int[,] nextField = new int[currentField.GetLength(0), currentField.GetLength(1)];
#LightBlue:int r = 0;
while (r < currentField.GetLength(0)) is (<color:green>yes)
    #LightBlue:int c = 0;
    while (c < currentField.GetLength(1)) is (<color:green>yes)
        #LightBlue:int neighbors = GetLivingNeighbors(currentField, r, c);
        if (currentField[r, c] == 0 && neighbors == 3) then (<color:green>yes)
          :nextField[r, c] = 1;
          else (<color:red>no)
            if (currentField[r, c] == 1 && neighbors < 2) then (<color:green>yes)
              :nextField[r, c] = 0;
              else (<color:red>no)
                if (currentField[r, c] == 1 && (neighbors == 2 || neighbors == 3)) then (<color:green>yes)
                  :nextField[r, c] = 1;
                  else (<color:red>no)
                    if (currentField[r, c] == 1 && neighbors > 3) then (<color:green>yes)
                      :nextField[r, c] = 0;
                      else (<color:red>no)
                        :nextField[r, c] = currentField[r, c];
                    endif
                endif
            endif
        endif
    :c++;
    endwhile (<color:red>no)
:r++;
endwhile (<color:red>no)
#Lavender:return nextField;
stop
start
note right:  Program.PrintField
#Lavender:Params(int[,] field);
:Console.Clear();
:Console.ForegroundColor = ConsoleColor.Yellow;
#LightBlue:int r = 0;
while (r < field.GetLength(0)) is (<color:green>yes)
    #LightBlue:int c = 0;
    while (c < field.GetLength(1)) is (<color:green>yes)
        #LightBlue:char sign = field[r, c] == 0 ? ' ' : '*';
        :Print($" {sign} ");
    :c++;
    endwhile (<color:red>no)
    :PrintLine();
:r++;
endwhile (<color:red>no)
stop
start
note right:  Program.CreateRandomField
#Lavender:Params(int rows, int cols, int occupancy);
#LightBlue:int count = 0
int[,] field = new int[Math.Max(rows, 0), Math.Max(cols, 0)];
:occupancy = Math.Min(occupancy, rows * cols);
while (count < occupancy) is (<color:green>yes)
    #LightBlue:int r = Random.Shared.Next(0, rows);
    #LightBlue:int c = Random.Shared.Next(0, cols);
    if (field[r, c] == 0) then (<color:green>yes)
        :field[r, c] = 1;
        :count++;
    endif
endwhile (<color:red>no)
#Lavender:return field;
stop
start
note right:  Program.ReadFieldFromCsvFile
#Lavender:Params(string filePath);
#LightBlue:bool isDefined = false
int[,] result = new int[0, 0];
if (File.Exists(filePath)) then (<color:green>yes)
    #LightBlue:string[] lines = File.ReadAllLines(filePath);
    #LightBlue:int r = 0;
    while (r < lines.Length) is (<color:green>yes)
        #LightBlue:string[] values = lines[r].Split(';');
        if (isDefined == false) then (<color:green>yes)
            :result = new int[lines.Length, values.Length];
            :isDefined = true;
        endif
        #LightBlue:int c = 0;
        while (c < values.Length) is (<color:green>yes)
            :result[r, c] = int.Parse(values[c]);
        :c++;
        endwhile (<color:red>no)
    :r++;
    endwhile (<color:red>no)
endif
#Lavender:return result;
stop
footer
generated with the DiagramCreator by Prof.Gehrer
end footer
@enduml
